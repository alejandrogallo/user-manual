#+title: Coupled-cluster theory calculations of rhombohedral boron nitride
#+OPTIONS: toc:nil

* Introduction

In this tutorial we explain all steps necessary to perform a  =Cc4s= calculation
on the level of CCSD(T) theory for a simple test system.

* Prerequisites

The following files are needed to reproduce all calculations of this tutorial.

- A working binary of =./Cc4s=   ( TODO add link to getting started section )
- A set of input files generated by the =VASP= interface ( TODO add link to test-resources )
  + $\Gamma^{pG}_{q}$ :  =CoulombVertex.yaml=, =CoulombVertex.dat=
  + $\epsilon_{p}$ : =EigenEnergies.yaml=, =EigenEnergies.dat=
  + $\vec G$ : =GridVectors.yaml=, =GridVectors.dat=
  + $\tilde{v}(\vec G)$ : =CoulombPotential.yaml=, =CoulombPotential.dat=
  + $\delta^{ab}_{ij}$ : =DeltaPPHH.yaml=, =DeltaPPHH.dat=
  + $\delta_{ij}$ : =DeltaHH.yaml=, =DeltaHH.dat=
  + $U_F^G$ : =CoulombVertexSingularVectors.yaml=, =CoulombVertexSingularVectors.dat=
  + $\epsilon_{ij}$ : =Mp2PairEnergies.yaml=, =Mp2PairEnergies.dat=

For the following example we assume that all above input files and =cc4s.in= are located in the same directory where
the =Cc4s= binary is called. The =cc4s.in= YAML input file is described in the following section.

* Description of CCSD calculations

=Cc4s= calculations are controlled by a YAML input file. Every input file consists of a list
of calls to algorithms with input arguments and output objects.
The output of any algorithm becomes available as potential input for all subsequent algorithm calls.

For the present tutorial we seek to compute the electronic correlation energy on the level of
CCSD(T) theory.
To this end =Cc4s= has to read in essential data files from disk, which can be achieved using the
=TensorReader= algorithm.
Here, we employ =./cc4s.in= as the YAML input file that controls =Cc4s= and we edit this file to contain the following code block

#+begin_src yaml
- name: TensorReader
  in:
    fileName: "CoulombVertex.yaml"
  out:
    tensor: CoulombVertex
#+end_src

The above call to the =TensorReader= algorithm reads in the
*CoulombVertex.yaml* file that contains all meta-information of the =CoulombVertex= tensor in a human-readable format.
If =Cc4s= is not in the dry-run mode (TODO: add link to dry-run description), it will also follow the link in
*CoulombVertex.yaml* to *CoulombVertex.dat* and read in all numerical data of the corresponding =CoulombVertex= tensor.
The output of =TensorReader= algorithm is the =CoulombVertex= tensor object, which can be used as input for all subsequent
=Cc4s= algorithms if needed.

In addition, we want =Cc4s= to read in the *EigenEnergies.yaml* and
*EigenEnergies.dat* files by including the following =TensorReader= call in the =./cc4s.in= file
#+begin_src yaml
- name: TensorReader
  in:
    fileName: "EigenEnergies.yaml"
  out:
    tensor: EigenEnergies
#+end_src

In the following step we include two further algorithm calls that are necessary to process the =CoulombVertex= and =EigenEnergies=
tensors in =Cc4s= and prepare them for coupled-cluster calculations. To this end the =./cc4s.in= file calls the
=DefineHolesAndParticles= and =SliceOperator= algorthims as described below

#+begin_src yaml
- name: DefineHolesAndParticles
  in:
    eigenEnergies: EigenEnergies
  out:
    slicedEigenEnergies: EigenEnergies

- name: SliceOperator
  in:
    slicedEigenEnergies: EigenEnergies
    operator: CoulombVertex
  out:
    slicedOperator: CoulombVertex
#+end_src

Note that we have now overwritten the original tensors stored in =CoulombVertex= and =EigenEnergies=,
turning them into objects of the type =slicedOperator= and =slicedEigenEnergies=, respectively.
Using these outputs, we can call the =VertexCoulombIntegrals= algorithm of =Cc4s= by including
the follow paragraph in the  =./cc4s.in= file
#+begin_src yaml
- name: VertexCoulombIntegrals
  in:
    slicedCoulombVertex: CoulombVertex
  out:
    coulombIntegrals: CoulombIntegrals
#+end_src

The =VertexCoulombIntegrals= algorithm produces the =CoulombIntegrals= output, which serves as input to the
=CoupledCluster= algorithm and is called using the following code block in  =./cc4s.in=

#+begin_src yaml
- name: CoupledCluster
  in:
    method:
      type: Ccsd
      integralsSliceSize: 100
    slicedEigenEnergies: EigenEnergies
    coulombIntegrals: CoulombIntegrals
    slicedCoulombVertex: CoulombVertex
    maxIterations: 30
    energyConvergence: 1.0E-5
    amplitudesConvergence: 1.0E-5
    mixer:
      type: DiisMixer
      maxResidua: 5
  out:
    energy: CcsdEnergy
    amplitudes: Amplitudes
#+end_src

If all code blocks given above are included in the =./cc4s.in= file and all other prerequisites all fulfilled,
=Cc4s= can be called by typing the following in the terminal:
#+begin_src sh
Cc4s -i cc4s.in
#+end_src

If all algorithms work successfully, the following output stream will appear on the terminal
#+begin_src sh

                __ __      
     __________/ // / _____
    / ___/ ___/ // /_/ ___/
   / /__/ /__/__  __(__  ) 
   \___/\___/  /_/ /____/  
  Coupled Cluster for Solids

version: heads/develop-0-g3c7f382, date: Fri Dec 17 16:11:36 2021 +0100
build date: Dec 21 2021 18:00:10
compiler: icc (ICC) 19.1.0.166 20191121
total processes: 1
calculation started on: Tue Dec 21 22:35:27 2021


execution plan read, steps: 6

step: 1, TensorReader
Reading from binary file CoulombVertex.dat
realtime 2.327871286 s
--
step: 2, TensorReader
Reading from text file EigenEnergies.dat
realtime 0.006519348 s
--
step: 3, DefineHolesAndParticles
number of holes     No: 16
number of particles Nv: 80
number of states    Np: 96
realtime 0.001037427 s
--
step: 4, SliceOperator
Slicing CoulombVertex.dat into holes and particles.
realtime 0.000913122 s
--
step: 5, VertexCoulombIntegrals
number of field variables NF: 356
realtime 0.015747318 s
--
step: 6, CoupledCluster
Using method Ccsd. integralsSliceSize: 100
Using mixer DiisMixer. maxResidua: 5
Maximum number of iterations: 30
Unless reaching energy convergence dE: 1e-05
and amplitudes convergence dR: 1e-05
Iter         Energy         dE           dR         time   GF/s/core
   1  -2.43605043e+01  -2.4361e+01   4.3924e-01      4.1    5.7
   2  -2.47577534e+01  -3.9725e-01   7.4733e-02     30.8    6.1
   3  -2.53776918e+01  -6.1994e-01   1.8674e-02     24.9    7.5
   4  -2.54455925e+01  -6.7901e-02   6.4132e-03     25.3    7.3
   5  -2.54445080e+01   1.0845e-03   2.2120e-03     25.8    7.2
   6  -2.54458312e+01  -1.3232e-03   1.0304e-03     25.7    7.2
   7  -2.54448941e+01   9.3705e-04   5.0727e-04     25.8    7.2
   8  -2.54452894e+01  -3.9521e-04   1.9694e-04     25.8    7.2
   9  -2.54454262e+01  -1.3682e-04   7.7180e-05     25.8    7.2
  10  -2.54455328e+01  -1.0663e-04   3.0247e-05     25.8    7.2
  11  -2.54455929e+01  -6.0110e-05   1.1758e-05     25.7    7.2
  12  -2.54456151e+01  -2.2218e-05   5.0053e-06     25.7    7.2
  13  -2.54456249e+01  -9.7454e-06   2.2689e-06     25.7    7.2

CCSD correlation energy:          -25.4456248862
2nd-order correlation energy:     -24.3605043096
realtime 317.059767911 s
--
total realtime: 319.445774591 s
total operations: 2267.4 GFLOPS, speed: 7.1 GFLOPS/s/core
#+end_src

* Description of finite-size correction to CCSD

* Description of basis-set incompleteness errors corrections to CCSD

* Description of CCSD(T) calculations


